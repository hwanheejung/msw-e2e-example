/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/dhlab-org/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import {
  HttpResponse,
  http,
  bypass,
  passthrough,
  type HttpResponseResolver,
} from "msw";
import { faker } from "@faker-js/faker";
import {
  type TStreamingEvent,
  selectResponseByScenario,
} from "@dataai/msw-auto-mock";
import { controllers } from "@tests/mocks/controllers/index.ts";
import { scenarios } from "../scenarios";

faker.seed(1);

const baseURL = "http://localhost:3000/api";
const MAX_ARRAY_LENGTH = 20;

export const usersHandlers = [
  http.get(`${baseURL}/users`, async (info) => {
    const isBypass = info.request.headers.get("x-bypass") === "true";

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn("[MSW] Bypass 실패, mock 데이터 사용:", error);
      }
    }

    const resultArray = [
      {
        status: 200,
        responseType: "application/json",
        body: JSON.stringify(await getGetUsersUsersGet200Response(info)),
      },
    ];
    const selectedResult = selectResponseByScenario(
      "get",
      "/users",
      resultArray,
      info,
      scenarios,
    );

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            "Content-Type": selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.post(`${baseURL}/users`, async (info) => {
    const isBypass = info.request.headers.get("x-bypass") === "true";

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn("[MSW] Bypass 실패, mock 데이터 사용:", error);
      }
    }

    const resultArray = [
      {
        status: 201,
        responseType: "application/json",
        body: JSON.stringify(await getCreateUserUsersPost201Response(info)),
      },
      {
        status: 400,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario(
      "post",
      "/users",
      resultArray,
      info,
      scenarios,
    );

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            "Content-Type": selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.get(`${baseURL}/users/:id`, async (info) => {
    const isBypass = info.request.headers.get("x-bypass") === "true";

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn("[MSW] Bypass 실패, mock 데이터 사용:", error);
      }
    }

    const resultArray = [
      {
        status: 200,
        responseType: "application/json",
        body: JSON.stringify(await getGetUserUsersIdGet200Response(info)),
      },
      {
        status: 404,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario(
      "get",
      "/users/:id",
      resultArray,
      info,
      scenarios,
    );

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            "Content-Type": selectedResult.responseType,
          }
        : undefined,
    });
  }),
];

export function getGetUsersUsersGet200Response(
  info: Parameters<HttpResponseResolver>[0],
) {
  return (
    controllers as Required<typeof controllers>
  ).getGetUsersUsersGet200Response(info);
}

export function getCreateUserUsersPost201Response() {
  return {
    id: faker.string.uuid(),
    username: faker.person.fullName(),
    email: faker.internet.email(),
    createdAt: faker.date.past(),
  };
}

export function getGetUserUsersIdGet200Response() {
  return {
    id: faker.string.uuid(),
    username: faker.person.fullName(),
    email: faker.internet.email(),
    createdAt: faker.date.past(),
  };
}
